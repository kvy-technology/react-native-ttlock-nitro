///
/// TtlockNitro-Swift-Cxx-Bridge.hpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

#pragma once

// Forward declarations of C++ defined types
// Forward declaration of `AnyMap` to properly resolve imports.
namespace NitroModules { class AnyMap; }
// Forward declaration of `CycleDateParam` to properly resolve imports.
namespace margelo::nitro::ttlocknitro { struct CycleDateParam; }
// Forward declaration of `DeviceSystemModal` to properly resolve imports.
namespace margelo::nitro::ttlocknitro { struct DeviceSystemModal; }
// Forward declaration of `HybridTtlockNitroSpec` to properly resolve imports.
namespace margelo::nitro::ttlocknitro { class HybridTtlockNitroSpec; }
// Forward declaration of `InitGatewayModal` to properly resolve imports.
namespace margelo::nitro::ttlocknitro { struct InitGatewayModal; }
// Forward declaration of `NumberBooleanPair` to properly resolve imports.
namespace margelo::nitro::ttlocknitro { struct NumberBooleanPair; }
// Forward declaration of `NumberNumberNumberTriple` to properly resolve imports.
namespace margelo::nitro::ttlocknitro { struct NumberNumberNumberTriple; }
// Forward declaration of `NumberNumberPair` to properly resolve imports.
namespace margelo::nitro::ttlocknitro { struct NumberNumberPair; }
// Forward declaration of `NumberStringPair` to properly resolve imports.
namespace margelo::nitro::ttlocknitro { struct NumberStringPair; }
// Forward declaration of `StringNumberPair` to properly resolve imports.
namespace margelo::nitro::ttlocknitro { struct StringNumberPair; }

// Forward declarations of Swift defined types
// Forward declaration of `HybridTtlockNitroSpec_cxx` to properly resolve imports.
namespace TtlockNitro { class HybridTtlockNitroSpec_cxx; }

// Include C++ defined types
#include "CycleDateParam.hpp"
#include "DeviceSystemModal.hpp"
#include "HybridTtlockNitroSpec.hpp"
#include "InitGatewayModal.hpp"
#include "NumberBooleanPair.hpp"
#include "NumberNumberNumberTriple.hpp"
#include "NumberNumberPair.hpp"
#include "NumberStringPair.hpp"
#include "StringNumberPair.hpp"
#include <NitroModules/AnyMap.hpp>
#include <NitroModules/FastVectorCopy.hpp>
#include <NitroModules/Result.hpp>
#include <exception>
#include <functional>
#include <memory>
#include <optional>
#include <string>
#include <vector>

/**
 * Contains specialized versions of C++ templated types so they can be accessed from Swift,
 * as well as helper functions to interact with those C++ types from Swift.
 */
namespace margelo::nitro::ttlocknitro::bridge::swift {

  // pragma MARK: std::function<void(const NumberStringPair& /* data */)>
  /**
   * Specialized version of `std::function<void(const NumberStringPair&)>`.
   */
  using Func_void_NumberStringPair = std::function<void(const NumberStringPair& /* data */)>;
  /**
   * Wrapper class for a `std::function<void(const NumberStringPair& / * data * /)>`, this can be used from Swift.
   */
  class Func_void_NumberStringPair_Wrapper final {
  public:
    explicit Func_void_NumberStringPair_Wrapper(std::function<void(const NumberStringPair& /* data */)>&& func): _function(std::make_unique<std::function<void(const NumberStringPair& /* data */)>>(std::move(func))) {}
    inline void call(NumberStringPair data) const noexcept {
      _function->operator()(data);
    }
  private:
    std::unique_ptr<std::function<void(const NumberStringPair& /* data */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_NumberStringPair create_Func_void_NumberStringPair(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_NumberStringPair_Wrapper wrap_Func_void_NumberStringPair(Func_void_NumberStringPair value) noexcept {
    return Func_void_NumberStringPair_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::function<void(double /* errorCode */, const std::string& /* description */)>
  /**
   * Specialized version of `std::function<void(double, const std::string&)>`.
   */
  using Func_void_double_std__string = std::function<void(double /* errorCode */, const std::string& /* description */)>;
  /**
   * Wrapper class for a `std::function<void(double / * errorCode * /, const std::string& / * description * /)>`, this can be used from Swift.
   */
  class Func_void_double_std__string_Wrapper final {
  public:
    explicit Func_void_double_std__string_Wrapper(std::function<void(double /* errorCode */, const std::string& /* description */)>&& func): _function(std::make_unique<std::function<void(double /* errorCode */, const std::string& /* description */)>>(std::move(func))) {}
    inline void call(double errorCode, std::string description) const noexcept {
      _function->operator()(errorCode, description);
    }
  private:
    std::unique_ptr<std::function<void(double /* errorCode */, const std::string& /* description */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_double_std__string create_Func_void_double_std__string(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_double_std__string_Wrapper wrap_Func_void_double_std__string(Func_void_double_std__string value) noexcept {
    return Func_void_double_std__string_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::function<void(const DeviceSystemModal& /* data */)>
  /**
   * Specialized version of `std::function<void(const DeviceSystemModal&)>`.
   */
  using Func_void_DeviceSystemModal = std::function<void(const DeviceSystemModal& /* data */)>;
  /**
   * Wrapper class for a `std::function<void(const DeviceSystemModal& / * data * /)>`, this can be used from Swift.
   */
  class Func_void_DeviceSystemModal_Wrapper final {
  public:
    explicit Func_void_DeviceSystemModal_Wrapper(std::function<void(const DeviceSystemModal& /* data */)>&& func): _function(std::make_unique<std::function<void(const DeviceSystemModal& /* data */)>>(std::move(func))) {}
    inline void call(DeviceSystemModal data) const noexcept {
      _function->operator()(data);
    }
  private:
    std::unique_ptr<std::function<void(const DeviceSystemModal& /* data */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_DeviceSystemModal create_Func_void_DeviceSystemModal(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_DeviceSystemModal_Wrapper wrap_Func_void_DeviceSystemModal(Func_void_DeviceSystemModal value) noexcept {
    return Func_void_DeviceSystemModal_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::function<void(double /* state */)>
  /**
   * Specialized version of `std::function<void(double)>`.
   */
  using Func_void_double = std::function<void(double /* state */)>;
  /**
   * Wrapper class for a `std::function<void(double / * state * /)>`, this can be used from Swift.
   */
  class Func_void_double_Wrapper final {
  public:
    explicit Func_void_double_Wrapper(std::function<void(double /* state */)>&& func): _function(std::make_unique<std::function<void(double /* state */)>>(std::move(func))) {}
    inline void call(double state) const noexcept {
      _function->operator()(state);
    }
  private:
    std::unique_ptr<std::function<void(double /* state */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_double create_Func_void_double(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_double_Wrapper wrap_Func_void_double(Func_void_double value) noexcept {
    return Func_void_double_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::optional<std::string>
  /**
   * Specialized version of `std::optional<std::string>`.
   */
  using std__optional_std__string_ = std::optional<std::string>;
  inline std::optional<std::string> create_std__optional_std__string_(const std::string& value) noexcept {
    return std::optional<std::string>(value);
  }
  inline bool has_value_std__optional_std__string_(const std::optional<std::string>& optional) noexcept {
    return optional.has_value();
  }
  inline std::string get_std__optional_std__string_(const std::optional<std::string>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::optional<double>
  /**
   * Specialized version of `std::optional<double>`.
   */
  using std__optional_double_ = std::optional<double>;
  inline std::optional<double> create_std__optional_double_(const double& value) noexcept {
    return std::optional<double>(value);
  }
  inline bool has_value_std__optional_double_(const std::optional<double>& optional) noexcept {
    return optional.has_value();
  }
  inline double get_std__optional_double_(const std::optional<double>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::function<void(const InitGatewayModal& /* data */)>
  /**
   * Specialized version of `std::function<void(const InitGatewayModal&)>`.
   */
  using Func_void_InitGatewayModal = std::function<void(const InitGatewayModal& /* data */)>;
  /**
   * Wrapper class for a `std::function<void(const InitGatewayModal& / * data * /)>`, this can be used from Swift.
   */
  class Func_void_InitGatewayModal_Wrapper final {
  public:
    explicit Func_void_InitGatewayModal_Wrapper(std::function<void(const InitGatewayModal& /* data */)>&& func): _function(std::make_unique<std::function<void(const InitGatewayModal& /* data */)>>(std::move(func))) {}
    inline void call(InitGatewayModal data) const noexcept {
      _function->operator()(data);
    }
  private:
    std::unique_ptr<std::function<void(const InitGatewayModal& /* data */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_InitGatewayModal create_Func_void_InitGatewayModal(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_InitGatewayModal_Wrapper wrap_Func_void_InitGatewayModal(Func_void_InitGatewayModal value) noexcept {
    return Func_void_InitGatewayModal_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::function<void(const std::string& /* lockData */)>
  /**
   * Specialized version of `std::function<void(const std::string&)>`.
   */
  using Func_void_std__string = std::function<void(const std::string& /* lockData */)>;
  /**
   * Wrapper class for a `std::function<void(const std::string& / * lockData * /)>`, this can be used from Swift.
   */
  class Func_void_std__string_Wrapper final {
  public:
    explicit Func_void_std__string_Wrapper(std::function<void(const std::string& /* lockData */)>&& func): _function(std::make_unique<std::function<void(const std::string& /* lockData */)>>(std::move(func))) {}
    inline void call(std::string lockData) const noexcept {
      _function->operator()(lockData);
    }
  private:
    std::unique_ptr<std::function<void(const std::string& /* lockData */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__string create_Func_void_std__string(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_std__string_Wrapper wrap_Func_void_std__string(Func_void_std__string value) noexcept {
    return Func_void_std__string_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::function<void(const NumberNumberPair& /* data */)>
  /**
   * Specialized version of `std::function<void(const NumberNumberPair&)>`.
   */
  using Func_void_NumberNumberPair = std::function<void(const NumberNumberPair& /* data */)>;
  /**
   * Wrapper class for a `std::function<void(const NumberNumberPair& / * data * /)>`, this can be used from Swift.
   */
  class Func_void_NumberNumberPair_Wrapper final {
  public:
    explicit Func_void_NumberNumberPair_Wrapper(std::function<void(const NumberNumberPair& /* data */)>&& func): _function(std::make_unique<std::function<void(const NumberNumberPair& /* data */)>>(std::move(func))) {}
    inline void call(NumberNumberPair data) const noexcept {
      _function->operator()(data);
    }
  private:
    std::unique_ptr<std::function<void(const NumberNumberPair& /* data */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_NumberNumberPair create_Func_void_NumberNumberPair(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_NumberNumberPair_Wrapper wrap_Func_void_NumberNumberPair(Func_void_NumberNumberPair value) noexcept {
    return Func_void_NumberNumberPair_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::function<void()>
  /**
   * Specialized version of `std::function<void()>`.
   */
  using Func_void = std::function<void()>;
  /**
   * Wrapper class for a `std::function<void()>`, this can be used from Swift.
   */
  class Func_void_Wrapper final {
  public:
    explicit Func_void_Wrapper(std::function<void()>&& func): _function(std::make_unique<std::function<void()>>(std::move(func))) {}
    inline void call() const noexcept {
      _function->operator()();
    }
  private:
    std::unique_ptr<std::function<void()>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void create_Func_void(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_Wrapper wrap_Func_void(Func_void value) noexcept {
    return Func_void_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::function<void(const NumberNumberNumberTriple& /* data */)>
  /**
   * Specialized version of `std::function<void(const NumberNumberNumberTriple&)>`.
   */
  using Func_void_NumberNumberNumberTriple = std::function<void(const NumberNumberNumberTriple& /* data */)>;
  /**
   * Wrapper class for a `std::function<void(const NumberNumberNumberTriple& / * data * /)>`, this can be used from Swift.
   */
  class Func_void_NumberNumberNumberTriple_Wrapper final {
  public:
    explicit Func_void_NumberNumberNumberTriple_Wrapper(std::function<void(const NumberNumberNumberTriple& /* data */)>&& func): _function(std::make_unique<std::function<void(const NumberNumberNumberTriple& /* data */)>>(std::move(func))) {}
    inline void call(NumberNumberNumberTriple data) const noexcept {
      _function->operator()(data);
    }
  private:
    std::unique_ptr<std::function<void(const NumberNumberNumberTriple& /* data */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_NumberNumberNumberTriple create_Func_void_NumberNumberNumberTriple(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_NumberNumberNumberTriple_Wrapper wrap_Func_void_NumberNumberNumberTriple(Func_void_NumberNumberNumberTriple value) noexcept {
    return Func_void_NumberNumberNumberTriple_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::vector<CycleDateParam>
  /**
   * Specialized version of `std::vector<CycleDateParam>`.
   */
  using std__vector_CycleDateParam_ = std::vector<CycleDateParam>;
  inline std::vector<CycleDateParam> copy_std__vector_CycleDateParam_(const CycleDateParam* CONTIGUOUS_MEMORY NON_NULL data, size_t size) noexcept {
    return margelo::nitro::FastVectorCopy<CycleDateParam>(data, size);
  }
  inline const CycleDateParam* CONTIGUOUS_MEMORY NON_NULL get_data_std__vector_CycleDateParam_(const std::vector<CycleDateParam>& vector) noexcept {
    return vector.data();
  }
  
  // pragma MARK: std::optional<std::vector<CycleDateParam>>
  /**
   * Specialized version of `std::optional<std::vector<CycleDateParam>>`.
   */
  using std__optional_std__vector_CycleDateParam__ = std::optional<std::vector<CycleDateParam>>;
  inline std::optional<std::vector<CycleDateParam>> create_std__optional_std__vector_CycleDateParam__(const std::vector<CycleDateParam>& value) noexcept {
    return std::optional<std::vector<CycleDateParam>>(value);
  }
  inline bool has_value_std__optional_std__vector_CycleDateParam__(const std::optional<std::vector<CycleDateParam>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::vector<CycleDateParam> get_std__optional_std__vector_CycleDateParam__(const std::optional<std::vector<CycleDateParam>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::function<void(bool /* isOn */)>
  /**
   * Specialized version of `std::function<void(bool)>`.
   */
  using Func_void_bool = std::function<void(bool /* isOn */)>;
  /**
   * Wrapper class for a `std::function<void(bool / * isOn * /)>`, this can be used from Swift.
   */
  class Func_void_bool_Wrapper final {
  public:
    explicit Func_void_bool_Wrapper(std::function<void(bool /* isOn */)>&& func): _function(std::make_unique<std::function<void(bool /* isOn */)>>(std::move(func))) {}
    inline void call(bool isOn) const noexcept {
      _function->operator()(isOn);
    }
  private:
    std::unique_ptr<std::function<void(bool /* isOn */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_bool create_Func_void_bool(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_bool_Wrapper wrap_Func_void_bool(Func_void_bool value) noexcept {
    return Func_void_bool_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::function<void(const NumberBooleanPair& /* data */)>
  /**
   * Specialized version of `std::function<void(const NumberBooleanPair&)>`.
   */
  using Func_void_NumberBooleanPair = std::function<void(const NumberBooleanPair& /* data */)>;
  /**
   * Wrapper class for a `std::function<void(const NumberBooleanPair& / * data * /)>`, this can be used from Swift.
   */
  class Func_void_NumberBooleanPair_Wrapper final {
  public:
    explicit Func_void_NumberBooleanPair_Wrapper(std::function<void(const NumberBooleanPair& /* data */)>&& func): _function(std::make_unique<std::function<void(const NumberBooleanPair& /* data */)>>(std::move(func))) {}
    inline void call(NumberBooleanPair data) const noexcept {
      _function->operator()(data);
    }
  private:
    std::unique_ptr<std::function<void(const NumberBooleanPair& /* data */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_NumberBooleanPair create_Func_void_NumberBooleanPair(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_NumberBooleanPair_Wrapper wrap_Func_void_NumberBooleanPair(Func_void_NumberBooleanPair value) noexcept {
    return Func_void_NumberBooleanPair_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::vector<double>
  /**
   * Specialized version of `std::vector<double>`.
   */
  using std__vector_double_ = std::vector<double>;
  inline std::vector<double> copy_std__vector_double_(const double* CONTIGUOUS_MEMORY NON_NULL data, size_t size) noexcept {
    return margelo::nitro::FastVectorCopy<double>(data, size);
  }
  inline const double* CONTIGUOUS_MEMORY NON_NULL get_data_std__vector_double_(const std::vector<double>& vector) noexcept {
    return vector.data();
  }
  
  // pragma MARK: std::optional<std::vector<double>>
  /**
   * Specialized version of `std::optional<std::vector<double>>`.
   */
  using std__optional_std__vector_double__ = std::optional<std::vector<double>>;
  inline std::optional<std::vector<double>> create_std__optional_std__vector_double__(const std::vector<double>& value) noexcept {
    return std::optional<std::vector<double>>(value);
  }
  inline bool has_value_std__optional_std__vector_double__(const std::optional<std::vector<double>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::vector<double> get_std__optional_std__vector_double__(const std::optional<std::vector<double>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::function<void(const StringNumberPair& /* data */)>
  /**
   * Specialized version of `std::function<void(const StringNumberPair&)>`.
   */
  using Func_void_StringNumberPair = std::function<void(const StringNumberPair& /* data */)>;
  /**
   * Wrapper class for a `std::function<void(const StringNumberPair& / * data * /)>`, this can be used from Swift.
   */
  class Func_void_StringNumberPair_Wrapper final {
  public:
    explicit Func_void_StringNumberPair_Wrapper(std::function<void(const StringNumberPair& /* data */)>&& func): _function(std::make_unique<std::function<void(const StringNumberPair& /* data */)>>(std::move(func))) {}
    inline void call(StringNumberPair data) const noexcept {
      _function->operator()(data);
    }
  private:
    std::unique_ptr<std::function<void(const StringNumberPair& /* data */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_StringNumberPair create_Func_void_StringNumberPair(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_StringNumberPair_Wrapper wrap_Func_void_StringNumberPair(Func_void_StringNumberPair value) noexcept {
    return Func_void_StringNumberPair_Wrapper(std::move(value));
  }
  
  // pragma MARK: std::optional<std::shared_ptr<AnyMap>>
  /**
   * Specialized version of `std::optional<std::shared_ptr<AnyMap>>`.
   */
  using std__optional_std__shared_ptr_AnyMap__ = std::optional<std::shared_ptr<AnyMap>>;
  inline std::optional<std::shared_ptr<AnyMap>> create_std__optional_std__shared_ptr_AnyMap__(const std::shared_ptr<AnyMap>& value) noexcept {
    return std::optional<std::shared_ptr<AnyMap>>(value);
  }
  inline bool has_value_std__optional_std__shared_ptr_AnyMap__(const std::optional<std::shared_ptr<AnyMap>>& optional) noexcept {
    return optional.has_value();
  }
  inline std::shared_ptr<AnyMap> get_std__optional_std__shared_ptr_AnyMap__(const std::optional<std::shared_ptr<AnyMap>>& optional) noexcept {
    return *optional;
  }
  
  // pragma MARK: std::function<void(const std::string& /* eventName */, const std::optional<std::shared_ptr<AnyMap>>& /* data */)>
  /**
   * Specialized version of `std::function<void(const std::string&, const std::optional<std::shared_ptr<AnyMap>>&)>`.
   */
  using Func_void_std__string_std__optional_std__shared_ptr_AnyMap__ = std::function<void(const std::string& /* eventName */, const std::optional<std::shared_ptr<AnyMap>>& /* data */)>;
  /**
   * Wrapper class for a `std::function<void(const std::string& / * eventName * /, const std::optional<std::shared_ptr<AnyMap>>& / * data * /)>`, this can be used from Swift.
   */
  class Func_void_std__string_std__optional_std__shared_ptr_AnyMap___Wrapper final {
  public:
    explicit Func_void_std__string_std__optional_std__shared_ptr_AnyMap___Wrapper(std::function<void(const std::string& /* eventName */, const std::optional<std::shared_ptr<AnyMap>>& /* data */)>&& func): _function(std::make_unique<std::function<void(const std::string& /* eventName */, const std::optional<std::shared_ptr<AnyMap>>& /* data */)>>(std::move(func))) {}
    inline void call(std::string eventName, std::optional<std::shared_ptr<AnyMap>> data) const noexcept {
      _function->operator()(eventName, data);
    }
  private:
    std::unique_ptr<std::function<void(const std::string& /* eventName */, const std::optional<std::shared_ptr<AnyMap>>& /* data */)>> _function;
  } SWIFT_NONCOPYABLE;
  Func_void_std__string_std__optional_std__shared_ptr_AnyMap__ create_Func_void_std__string_std__optional_std__shared_ptr_AnyMap__(void* NON_NULL swiftClosureWrapper) noexcept;
  inline Func_void_std__string_std__optional_std__shared_ptr_AnyMap___Wrapper wrap_Func_void_std__string_std__optional_std__shared_ptr_AnyMap__(Func_void_std__string_std__optional_std__shared_ptr_AnyMap__ value) noexcept {
    return Func_void_std__string_std__optional_std__shared_ptr_AnyMap___Wrapper(std::move(value));
  }
  
  // pragma MARK: std::shared_ptr<HybridTtlockNitroSpec>
  /**
   * Specialized version of `std::shared_ptr<HybridTtlockNitroSpec>`.
   */
  using std__shared_ptr_HybridTtlockNitroSpec_ = std::shared_ptr<HybridTtlockNitroSpec>;
  std::shared_ptr<HybridTtlockNitroSpec> create_std__shared_ptr_HybridTtlockNitroSpec_(void* NON_NULL swiftUnsafePointer) noexcept;
  void* NON_NULL get_std__shared_ptr_HybridTtlockNitroSpec_(std__shared_ptr_HybridTtlockNitroSpec_ cppType) noexcept;
  
  // pragma MARK: std::weak_ptr<HybridTtlockNitroSpec>
  using std__weak_ptr_HybridTtlockNitroSpec_ = std::weak_ptr<HybridTtlockNitroSpec>;
  inline std__weak_ptr_HybridTtlockNitroSpec_ weakify_std__shared_ptr_HybridTtlockNitroSpec_(const std::shared_ptr<HybridTtlockNitroSpec>& strong) noexcept { return strong; }
  
  // pragma MARK: Result<void>
  using Result_void_ = Result<void>;
  inline Result_void_ create_Result_void_() noexcept {
    return Result<void>::withValue();
  }
  inline Result_void_ create_Result_void_(const std::exception_ptr& error) noexcept {
    return Result<void>::withError(error);
  }

} // namespace margelo::nitro::ttlocknitro::bridge::swift
