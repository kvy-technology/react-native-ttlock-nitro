///
/// HybridTtlockNitroSpec_cxx.swift
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

import Foundation
import NitroModules

/**
 * A class implementation that bridges HybridTtlockNitroSpec over to C++.
 * In C++, we cannot use Swift protocols - so we need to wrap it in a class to make it strongly defined.
 *
 * Also, some Swift types need to be bridged with special handling:
 * - Enums need to be wrapped in Structs, otherwise they cannot be accessed bi-directionally (Swift bug: https://github.com/swiftlang/swift/issues/75330)
 * - Other HybridObjects need to be wrapped/unwrapped from the Swift TCxx wrapper
 * - Throwing methods need to be wrapped with a Result<T, Error> type, as exceptions cannot be propagated to C++
 */
open class HybridTtlockNitroSpec_cxx {
  /**
   * The Swift <> C++ bridge's namespace (`margelo::nitro::ttlocknitro::bridge::swift`)
   * from `TtlockNitro-Swift-Cxx-Bridge.hpp`.
   * This contains specialized C++ templates, and C++ helper functions that can be accessed from Swift.
   */
  public typealias bridge = margelo.nitro.ttlocknitro.bridge.swift

  /**
   * Holds an instance of the `HybridTtlockNitroSpec` Swift protocol.
   */
  private var __implementation: any HybridTtlockNitroSpec

  /**
   * Holds a weak pointer to the C++ class that wraps the Swift class.
   */
  private var __cxxPart: bridge.std__weak_ptr_HybridTtlockNitroSpec_

  /**
   * Create a new `HybridTtlockNitroSpec_cxx` that wraps the given `HybridTtlockNitroSpec`.
   * All properties and methods bridge to C++ types.
   */
  public init(_ implementation: any HybridTtlockNitroSpec) {
    self.__implementation = implementation
    self.__cxxPart = .init()
    /* no base class */
  }

  /**
   * Get the actual `HybridTtlockNitroSpec` instance this class wraps.
   */
  @inline(__always)
  public func getHybridTtlockNitroSpec() -> any HybridTtlockNitroSpec {
    return __implementation
  }

  /**
   * Casts this instance to a retained unsafe raw pointer.
   * This acquires one additional strong reference on the object!
   */
  public func toUnsafe() -> UnsafeMutableRawPointer {
    return Unmanaged.passRetained(self).toOpaque()
  }

  /**
   * Casts an unsafe pointer to a `HybridTtlockNitroSpec_cxx`.
   * The pointer has to be a retained opaque `Unmanaged<HybridTtlockNitroSpec_cxx>`.
   * This removes one strong reference from the object!
   */
  public class func fromUnsafe(_ pointer: UnsafeMutableRawPointer) -> HybridTtlockNitroSpec_cxx {
    return Unmanaged<HybridTtlockNitroSpec_cxx>.fromOpaque(pointer).takeRetainedValue()
  }

  /**
   * Gets (or creates) the C++ part of this Hybrid Object.
   * The C++ part is a `std::shared_ptr<HybridTtlockNitroSpec>`.
   */
  public func getCxxPart() -> bridge.std__shared_ptr_HybridTtlockNitroSpec_ {
    let cachedCxxPart = self.__cxxPart.lock()
    if cachedCxxPart.__convertToBool() {
      return cachedCxxPart
    } else {
      let newCxxPart = bridge.create_std__shared_ptr_HybridTtlockNitroSpec_(self.toUnsafe())
      __cxxPart = bridge.weakify_std__shared_ptr_HybridTtlockNitroSpec_(newCxxPart)
      return newCxxPart
    }
  }

  

  /**
   * Get the memory size of the Swift class (plus size of any other allocations)
   * so the JS VM can properly track it and garbage-collect the JS object if needed.
   */
  @inline(__always)
  public var memorySize: Int {
    return MemoryHelper.getSizeOf(self.__implementation) + self.__implementation.memorySize
  }

  /**
   * Call dispose() on the Swift class.
   * This _may_ be called manually from JS.
   */
  @inline(__always)
  public func dispose() {
    self.__implementation.dispose()
  }

  // Properties
  

  // Methods
  @inline(__always)
  public final func startScanWirelessKeypad() -> bridge.Result_void_ {
    do {
      try self.__implementation.startScanWirelessKeypad()
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func stopScanWirelessKeypad() -> bridge.Result_void_ {
    do {
      try self.__implementation.stopScanWirelessKeypad()
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func initWirelessKeypad(keypadMac: std.string, lockMac: std.string, resolve: bridge.Func_void_NumberStringPair, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.initWirelessKeypad(keypadMac: String(keypadMac), lockMac: String(lockMac), resolve: { () -> (NumberStringPair) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_NumberStringPair(resolve)
        return { (__data: NumberStringPair) -> Void in
          __wrappedFunction.call(__data)
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func startScanDoorSensor() -> bridge.Result_void_ {
    do {
      try self.__implementation.startScanDoorSensor()
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func stopScanDoorSensor() -> bridge.Result_void_ {
    do {
      try self.__implementation.stopScanDoorSensor()
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func initDoorSensor(doorSensorMac: std.string, lockData: std.string, resolve: bridge.Func_void_NumberStringPair, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.initDoorSensor(doorSensorMac: String(doorSensorMac), lockData: String(lockData), resolve: { () -> (NumberStringPair) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_NumberStringPair(resolve)
        return { (__data: NumberStringPair) -> Void in
          __wrappedFunction.call(__data)
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func startScanRemoteKey() -> bridge.Result_void_ {
    do {
      try self.__implementation.startScanRemoteKey()
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func stopScanRemoteKey() -> bridge.Result_void_ {
    do {
      try self.__implementation.stopScanRemoteKey()
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func initRemoteKey(remoteMac: std.string, lockData: std.string, resolve: bridge.Func_void_NumberStringPair, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.initRemoteKey(remoteMac: String(remoteMac), lockData: String(lockData), resolve: { () -> (NumberStringPair) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_NumberStringPair(resolve)
        return { (__data: NumberStringPair) -> Void in
          __wrappedFunction.call(__data)
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func getRemoteKeySystemInfo(remoteMac: std.string, resolve: bridge.Func_void_DeviceSystemModal, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.getRemoteKeySystemInfo(remoteMac: String(remoteMac), resolve: { () -> (DeviceSystemModal) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_DeviceSystemModal(resolve)
        return { (__data: DeviceSystemModal) -> Void in
          __wrappedFunction.call(__data)
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func startScanGateway() -> bridge.Result_void_ {
    do {
      try self.__implementation.startScanGateway()
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func stopScanGateway() -> bridge.Result_void_ {
    do {
      try self.__implementation.stopScanGateway()
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func connect(mac: std.string, resolve: bridge.Func_void_double) -> bridge.Result_void_ {
    do {
      try self.__implementation.connect(mac: String(mac), resolve: { () -> (Double) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double(resolve)
        return { (__state: Double) -> Void in
          __wrappedFunction.call(__state)
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func getNearbyWifi(resolve: bridge.Func_void_double) -> bridge.Result_void_ {
    do {
      try self.__implementation.getNearbyWifi(resolve: { () -> (Double) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double(resolve)
        return { (__state: Double) -> Void in
          __wrappedFunction.call(__state)
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func initGateway(params: InitGatewayParam, resolve: bridge.Func_void_InitGatewayModal, reject: bridge.Func_void_double) -> bridge.Result_void_ {
    do {
      try self.__implementation.initGateway(params: params, resolve: { () -> (InitGatewayModal) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_InitGatewayModal(resolve)
        return { (__data: InitGatewayModal) -> Void in
          __wrappedFunction.call(__data)
        }
      }(), reject: { () -> (Double) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double(reject)
        return { (__errorCode: Double) -> Void in
          __wrappedFunction.call(__errorCode)
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func startScan() -> bridge.Result_void_ {
    do {
      try self.__implementation.startScan()
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func stopScan() -> bridge.Result_void_ {
    do {
      try self.__implementation.stopScan()
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func initLock(params: InitLockParam, resolve: bridge.Func_void_std__string, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.initLock(params: params, resolve: { () -> (String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_std__string(resolve)
        return { (__lockData: String) -> Void in
          __wrappedFunction.call(std.string(__lockData))
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func getLockVersionWithLockMac(lockMac: std.string, resolve: bridge.Func_void_std__string, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.getLockVersionWithLockMac(lockMac: String(lockMac), resolve: { () -> (String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_std__string(resolve)
        return { (__lockVersion: String) -> Void in
          __wrappedFunction.call(std.string(__lockVersion))
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func getAccessoryElectricQuantity(accessoryType: Double, accessoryMac: std.string, lockData: std.string, resolve: bridge.Func_void_NumberNumberPair, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.getAccessoryElectricQuantity(accessoryType: accessoryType, accessoryMac: String(accessoryMac), lockData: String(lockData), resolve: { () -> (NumberNumberPair) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_NumberNumberPair(resolve)
        return { (__data: NumberNumberPair) -> Void in
          __wrappedFunction.call(__data)
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func resetLock(lockData: std.string, resolve: bridge.Func_void, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.resetLock(lockData: String(lockData), resolve: { () -> () -> Void in
        let __wrappedFunction = bridge.wrap_Func_void(resolve)
        return { () -> Void in
          __wrappedFunction.call()
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func resetEkey(lockData: std.string, resolve: bridge.Func_void_std__string, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.resetEkey(lockData: String(lockData), resolve: { () -> (String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_std__string(resolve)
        return { (__lockData: String) -> Void in
          __wrappedFunction.call(std.string(__lockData))
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func controlLock(controlAction: Double, lockData: std.string, resolve: bridge.Func_void_NumberNumberNumberTriple, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.controlLock(controlAction: controlAction, lockData: String(lockData), resolve: { () -> (NumberNumberNumberTriple) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_NumberNumberNumberTriple(resolve)
        return { (__data: NumberNumberNumberTriple) -> Void in
          __wrappedFunction.call(__data)
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func createCustomPasscode(passcode: std.string, startDate: Double, endDate: Double, lockData: std.string, resolve: bridge.Func_void, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.createCustomPasscode(passcode: String(passcode), startDate: startDate, endDate: endDate, lockData: String(lockData), resolve: { () -> () -> Void in
        let __wrappedFunction = bridge.wrap_Func_void(resolve)
        return { () -> Void in
          __wrappedFunction.call()
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func recoverPasscode(passcode: std.string, passcodeType: Double, cycleType: Double, startDate: Double, endDate: Double, lockData: std.string, resolve: bridge.Func_void, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.recoverPasscode(passcode: String(passcode), passcodeType: passcodeType, cycleType: cycleType, startDate: startDate, endDate: endDate, lockData: String(lockData), resolve: { () -> () -> Void in
        let __wrappedFunction = bridge.wrap_Func_void(resolve)
        return { () -> Void in
          __wrappedFunction.call()
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func modifyPasscode(passcodeOrigin: std.string, passcodeNew: std.string, startDate: Double, endDate: Double, lockData: std.string, resolve: bridge.Func_void, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.modifyPasscode(passcodeOrigin: String(passcodeOrigin), passcodeNew: String(passcodeNew), startDate: startDate, endDate: endDate, lockData: String(lockData), resolve: { () -> () -> Void in
        let __wrappedFunction = bridge.wrap_Func_void(resolve)
        return { () -> Void in
          __wrappedFunction.call()
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func deletePasscode(passcode: std.string, lockData: std.string, resolve: bridge.Func_void, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.deletePasscode(passcode: String(passcode), lockData: String(lockData), resolve: { () -> () -> Void in
        let __wrappedFunction = bridge.wrap_Func_void(resolve)
        return { () -> Void in
          __wrappedFunction.call()
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func resetPasscode(lockData: std.string, resolve: bridge.Func_void_std__string, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.resetPasscode(lockData: String(lockData), resolve: { () -> (String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_std__string(resolve)
        return { (__lockData: String) -> Void in
          __wrappedFunction.call(std.string(__lockData))
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func getLockSwitchState(lockData: std.string, resolve: bridge.Func_void_double, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.getLockSwitchState(lockData: String(lockData), resolve: { () -> (Double) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double(resolve)
        return { (__state: Double) -> Void in
          __wrappedFunction.call(__state)
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func addCard(cycleList: bridge.std__optional_std__vector_CycleDateParam__, startDate: Double, endDate: Double, lockData: std.string, resolve: bridge.Func_void_std__string, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.addCard(cycleList: { () -> [CycleDateParam]? in
        if bridge.has_value_std__optional_std__vector_CycleDateParam__(cycleList) {
          let __unwrapped = bridge.get_std__optional_std__vector_CycleDateParam__(cycleList)
          return { () -> [CycleDateParam] in
            let __data = bridge.get_data_std__vector_CycleDateParam_(__unwrapped)
            let __size = __unwrapped.size()
            return Array(UnsafeBufferPointer(start: __data, count: __size))
          }()
        } else {
          return nil
        }
      }(), startDate: startDate, endDate: endDate, lockData: String(lockData), resolve: { () -> (String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_std__string(resolve)
        return { (__cardNumber: String) -> Void in
          __wrappedFunction.call(std.string(__cardNumber))
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func recoverCard(cardNumber: std.string, cycleList: bridge.std__optional_std__vector_CycleDateParam__, startDate: Double, endDate: Double, lockData: std.string, resolve: bridge.Func_void, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.recoverCard(cardNumber: String(cardNumber), cycleList: { () -> [CycleDateParam]? in
        if bridge.has_value_std__optional_std__vector_CycleDateParam__(cycleList) {
          let __unwrapped = bridge.get_std__optional_std__vector_CycleDateParam__(cycleList)
          return { () -> [CycleDateParam] in
            let __data = bridge.get_data_std__vector_CycleDateParam_(__unwrapped)
            let __size = __unwrapped.size()
            return Array(UnsafeBufferPointer(start: __data, count: __size))
          }()
        } else {
          return nil
        }
      }(), startDate: startDate, endDate: endDate, lockData: String(lockData), resolve: { () -> () -> Void in
        let __wrappedFunction = bridge.wrap_Func_void(resolve)
        return { () -> Void in
          __wrappedFunction.call()
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func modifyCardValidityPeriod(cardNumber: std.string, cycleList: bridge.std__optional_std__vector_CycleDateParam__, startDate: Double, endDate: Double, lockData: std.string, resolve: bridge.Func_void, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.modifyCardValidityPeriod(cardNumber: String(cardNumber), cycleList: { () -> [CycleDateParam]? in
        if bridge.has_value_std__optional_std__vector_CycleDateParam__(cycleList) {
          let __unwrapped = bridge.get_std__optional_std__vector_CycleDateParam__(cycleList)
          return { () -> [CycleDateParam] in
            let __data = bridge.get_data_std__vector_CycleDateParam_(__unwrapped)
            let __size = __unwrapped.size()
            return Array(UnsafeBufferPointer(start: __data, count: __size))
          }()
        } else {
          return nil
        }
      }(), startDate: startDate, endDate: endDate, lockData: String(lockData), resolve: { () -> () -> Void in
        let __wrappedFunction = bridge.wrap_Func_void(resolve)
        return { () -> Void in
          __wrappedFunction.call()
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func deleteCard(cardNumber: std.string, lockData: std.string, resolve: bridge.Func_void, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.deleteCard(cardNumber: String(cardNumber), lockData: String(lockData), resolve: { () -> () -> Void in
        let __wrappedFunction = bridge.wrap_Func_void(resolve)
        return { () -> Void in
          __wrappedFunction.call()
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func clearAllCards(lockData: std.string, resolve: bridge.Func_void, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.clearAllCards(lockData: String(lockData), resolve: { () -> () -> Void in
        let __wrappedFunction = bridge.wrap_Func_void(resolve)
        return { () -> Void in
          __wrappedFunction.call()
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func addFingerprint(cycleList: bridge.std__optional_std__vector_CycleDateParam__, startDate: Double, endDate: Double, lockData: std.string, resolve: bridge.Func_void_std__string, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.addFingerprint(cycleList: { () -> [CycleDateParam]? in
        if bridge.has_value_std__optional_std__vector_CycleDateParam__(cycleList) {
          let __unwrapped = bridge.get_std__optional_std__vector_CycleDateParam__(cycleList)
          return { () -> [CycleDateParam] in
            let __data = bridge.get_data_std__vector_CycleDateParam_(__unwrapped)
            let __size = __unwrapped.size()
            return Array(UnsafeBufferPointer(start: __data, count: __size))
          }()
        } else {
          return nil
        }
      }(), startDate: startDate, endDate: endDate, lockData: String(lockData), resolve: { () -> (String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_std__string(resolve)
        return { (__fingerprintNumber: String) -> Void in
          __wrappedFunction.call(std.string(__fingerprintNumber))
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func modifyFingerprintValidityPeriod(fingerprintNumber: std.string, cycleList: bridge.std__optional_std__vector_CycleDateParam__, startDate: Double, endDate: Double, lockData: std.string, resolve: bridge.Func_void, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.modifyFingerprintValidityPeriod(fingerprintNumber: String(fingerprintNumber), cycleList: { () -> [CycleDateParam]? in
        if bridge.has_value_std__optional_std__vector_CycleDateParam__(cycleList) {
          let __unwrapped = bridge.get_std__optional_std__vector_CycleDateParam__(cycleList)
          return { () -> [CycleDateParam] in
            let __data = bridge.get_data_std__vector_CycleDateParam_(__unwrapped)
            let __size = __unwrapped.size()
            return Array(UnsafeBufferPointer(start: __data, count: __size))
          }()
        } else {
          return nil
        }
      }(), startDate: startDate, endDate: endDate, lockData: String(lockData), resolve: { () -> () -> Void in
        let __wrappedFunction = bridge.wrap_Func_void(resolve)
        return { () -> Void in
          __wrappedFunction.call()
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func deleteFingerprint(fingerprintNumber: std.string, lockData: std.string, resolve: bridge.Func_void, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.deleteFingerprint(fingerprintNumber: String(fingerprintNumber), lockData: String(lockData), resolve: { () -> () -> Void in
        let __wrappedFunction = bridge.wrap_Func_void(resolve)
        return { () -> Void in
          __wrappedFunction.call()
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func clearAllFingerprints(lockData: std.string, resolve: bridge.Func_void, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.clearAllFingerprints(lockData: String(lockData), resolve: { () -> () -> Void in
        let __wrappedFunction = bridge.wrap_Func_void(resolve)
        return { () -> Void in
          __wrappedFunction.call()
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func modifyAdminPasscode(adminPasscode: std.string, lockData: std.string, resolve: bridge.Func_void_std__string, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.modifyAdminPasscode(adminPasscode: String(adminPasscode), lockData: String(lockData), resolve: { () -> (String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_std__string(resolve)
        return { (__passcode: String) -> Void in
          __wrappedFunction.call(std.string(__passcode))
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func setLockTime(timestamp: Double, lockData: std.string, resolve: bridge.Func_void, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.setLockTime(timestamp: timestamp, lockData: String(lockData), resolve: { () -> () -> Void in
        let __wrappedFunction = bridge.wrap_Func_void(resolve)
        return { () -> Void in
          __wrappedFunction.call()
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func getLockTime(lockData: std.string, resolve: bridge.Func_void_std__string, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.getLockTime(lockData: String(lockData), resolve: { () -> (String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_std__string(resolve)
        return { (__lockTimestamp: String) -> Void in
          __wrappedFunction.call(std.string(__lockTimestamp))
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func getLockSystem(lockData: std.string, resolve: bridge.Func_void_DeviceSystemModal, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.getLockSystem(lockData: String(lockData), resolve: { () -> (DeviceSystemModal) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_DeviceSystemModal(resolve)
        return { (__systemInfo: DeviceSystemModal) -> Void in
          __wrappedFunction.call(__systemInfo)
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func getLockElectricQuantity(lockData: std.string, resolve: bridge.Func_void_double, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.getLockElectricQuantity(lockData: String(lockData), resolve: { () -> (Double) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double(resolve)
        return { (__electricQuantity: Double) -> Void in
          __wrappedFunction.call(__electricQuantity)
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func getLockOperationRecord(type: Double, lockData: std.string, resolve: bridge.Func_void_std__string, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.getLockOperationRecord(type: type, lockData: String(lockData), resolve: { () -> (String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_std__string(resolve)
        return { (__records: String) -> Void in
          __wrappedFunction.call(std.string(__records))
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func getLockAutomaticLockingPeriodicTime(lockData: std.string, resolve: bridge.Func_void_NumberNumberNumberTriple, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.getLockAutomaticLockingPeriodicTime(lockData: String(lockData), resolve: { () -> (NumberNumberNumberTriple) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_NumberNumberNumberTriple(resolve)
        return { (__data: NumberNumberNumberTriple) -> Void in
          __wrappedFunction.call(__data)
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func setLockAutomaticLockingPeriodicTime(seconds: Double, lockData: std.string, resolve: bridge.Func_void, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.setLockAutomaticLockingPeriodicTime(seconds: seconds, lockData: String(lockData), resolve: { () -> () -> Void in
        let __wrappedFunction = bridge.wrap_Func_void(resolve)
        return { () -> Void in
          __wrappedFunction.call()
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func getLockRemoteUnlockSwitchState(lockData: std.string, resolve: bridge.Func_void_bool, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.getLockRemoteUnlockSwitchState(lockData: String(lockData), resolve: { () -> (Bool) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_bool(resolve)
        return { (__isOn: Bool) -> Void in
          __wrappedFunction.call(__isOn)
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func setLockRemoteUnlockSwitchState(isOn: Bool, lockData: std.string, resolve: bridge.Func_void_std__string, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.setLockRemoteUnlockSwitchState(isOn: isOn, lockData: String(lockData), resolve: { () -> (String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_std__string(resolve)
        return { (__lockData: String) -> Void in
          __wrappedFunction.call(std.string(__lockData))
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func getLockConfig(config: Double, lockData: std.string, resolve: bridge.Func_void_NumberBooleanPair, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.getLockConfig(config: config, lockData: String(lockData), resolve: { () -> (NumberBooleanPair) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_NumberBooleanPair(resolve)
        return { (__data: NumberBooleanPair) -> Void in
          __wrappedFunction.call(__data)
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func setLockConfig(config: Double, isOn: Bool, lockData: std.string, resolve: bridge.Func_void, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.setLockConfig(config: config, isOn: isOn, lockData: String(lockData), resolve: { () -> () -> Void in
        let __wrappedFunction = bridge.wrap_Func_void(resolve)
        return { () -> Void in
          __wrappedFunction.call()
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func setLockSoundVolume(soundVolumeValue: Double, lockData: std.string, resolve: bridge.Func_void, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.setLockSoundVolume(soundVolumeValue: soundVolumeValue, lockData: String(lockData), resolve: { () -> () -> Void in
        let __wrappedFunction = bridge.wrap_Func_void(resolve)
        return { () -> Void in
          __wrappedFunction.call()
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func getLockSoundVolume(lockData: std.string, resolve: bridge.Func_void_double, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.getLockSoundVolume(lockData: String(lockData), resolve: { () -> (Double) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double(resolve)
        return { (__soundVolumeValue: Double) -> Void in
          __wrappedFunction.call(__soundVolumeValue)
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func getUnlockDirection(lockData: std.string, resolve: bridge.Func_void_double, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.getUnlockDirection(lockData: String(lockData), resolve: { () -> (Double) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double(resolve)
        return { (__direction: Double) -> Void in
          __wrappedFunction.call(__direction)
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func setUnlockDirection(direction: Double, lockData: std.string, resolve: bridge.Func_void, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.setUnlockDirection(direction: direction, lockData: String(lockData), resolve: { () -> () -> Void in
        let __wrappedFunction = bridge.wrap_Func_void(resolve)
        return { () -> Void in
          __wrappedFunction.call()
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func setUnlockDirectionAutomatic(lockData: std.string, resolve: bridge.Func_void_double, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.setUnlockDirectionAutomatic(lockData: String(lockData), resolve: { () -> (Double) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double(resolve)
        return { (__direction: Double) -> Void in
          __wrappedFunction.call(__direction)
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func addPassageMode(type: Double, weekly: bridge.std__optional_std__vector_double__, monthly: bridge.std__optional_std__vector_double__, startDate: Double, endDate: Double, lockData: std.string, resolve: bridge.Func_void, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.addPassageMode(type: type, weekly: { () -> [Double]? in
        if bridge.has_value_std__optional_std__vector_double__(weekly) {
          let __unwrapped = bridge.get_std__optional_std__vector_double__(weekly)
          return { () -> [Double] in
            let __data = bridge.get_data_std__vector_double_(__unwrapped)
            let __size = __unwrapped.size()
            return Array(UnsafeBufferPointer(start: __data, count: __size))
          }()
        } else {
          return nil
        }
      }(), monthly: { () -> [Double]? in
        if bridge.has_value_std__optional_std__vector_double__(monthly) {
          let __unwrapped = bridge.get_std__optional_std__vector_double__(monthly)
          return { () -> [Double] in
            let __data = bridge.get_data_std__vector_double_(__unwrapped)
            let __size = __unwrapped.size()
            return Array(UnsafeBufferPointer(start: __data, count: __size))
          }()
        } else {
          return nil
        }
      }(), startDate: startDate, endDate: endDate, lockData: String(lockData), resolve: { () -> () -> Void in
        let __wrappedFunction = bridge.wrap_Func_void(resolve)
        return { () -> Void in
          __wrappedFunction.call()
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func clearAllPassageModes(lockData: std.string, resolve: bridge.Func_void, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.clearAllPassageModes(lockData: String(lockData), resolve: { () -> () -> Void in
        let __wrappedFunction = bridge.wrap_Func_void(resolve)
        return { () -> Void in
          __wrappedFunction.call()
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func addRemoteKey(remoteMac: std.string, cycleList: bridge.std__optional_std__vector_CycleDateParam__, startDate: Double, endDate: Double, lockData: std.string, resolve: bridge.Func_void, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.addRemoteKey(remoteMac: String(remoteMac), cycleList: { () -> [CycleDateParam]? in
        if bridge.has_value_std__optional_std__vector_CycleDateParam__(cycleList) {
          let __unwrapped = bridge.get_std__optional_std__vector_CycleDateParam__(cycleList)
          return { () -> [CycleDateParam] in
            let __data = bridge.get_data_std__vector_CycleDateParam_(__unwrapped)
            let __size = __unwrapped.size()
            return Array(UnsafeBufferPointer(start: __data, count: __size))
          }()
        } else {
          return nil
        }
      }(), startDate: startDate, endDate: endDate, lockData: String(lockData), resolve: { () -> () -> Void in
        let __wrappedFunction = bridge.wrap_Func_void(resolve)
        return { () -> Void in
          __wrappedFunction.call()
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func modifyRemoteKey(remoteMac: std.string, cycleList: bridge.std__optional_std__vector_CycleDateParam__, startDate: Double, endDate: Double, lockData: std.string, resolve: bridge.Func_void, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.modifyRemoteKey(remoteMac: String(remoteMac), cycleList: { () -> [CycleDateParam]? in
        if bridge.has_value_std__optional_std__vector_CycleDateParam__(cycleList) {
          let __unwrapped = bridge.get_std__optional_std__vector_CycleDateParam__(cycleList)
          return { () -> [CycleDateParam] in
            let __data = bridge.get_data_std__vector_CycleDateParam_(__unwrapped)
            let __size = __unwrapped.size()
            return Array(UnsafeBufferPointer(start: __data, count: __size))
          }()
        } else {
          return nil
        }
      }(), startDate: startDate, endDate: endDate, lockData: String(lockData), resolve: { () -> () -> Void in
        let __wrappedFunction = bridge.wrap_Func_void(resolve)
        return { () -> Void in
          __wrappedFunction.call()
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func deleteRemoteKey(remoteMac: std.string, lockData: std.string, resolve: bridge.Func_void, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.deleteRemoteKey(remoteMac: String(remoteMac), lockData: String(lockData), resolve: { () -> () -> Void in
        let __wrappedFunction = bridge.wrap_Func_void(resolve)
        return { () -> Void in
          __wrappedFunction.call()
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func clearAllRemoteKey(lockData: std.string, resolve: bridge.Func_void, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.clearAllRemoteKey(lockData: String(lockData), resolve: { () -> () -> Void in
        let __wrappedFunction = bridge.wrap_Func_void(resolve)
        return { () -> Void in
          __wrappedFunction.call()
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func addDoorSensor(doorSensorMac: std.string, lockData: std.string, resolve: bridge.Func_void, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.addDoorSensor(doorSensorMac: String(doorSensorMac), lockData: String(lockData), resolve: { () -> () -> Void in
        let __wrappedFunction = bridge.wrap_Func_void(resolve)
        return { () -> Void in
          __wrappedFunction.call()
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func clearAllDoorSensor(lockData: std.string, resolve: bridge.Func_void, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.clearAllDoorSensor(lockData: String(lockData), resolve: { () -> () -> Void in
        let __wrappedFunction = bridge.wrap_Func_void(resolve)
        return { () -> Void in
          __wrappedFunction.call()
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func setDoorSensorAlertTime(time: Double, lockData: std.string, resolve: bridge.Func_void, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.setDoorSensorAlertTime(time: time, lockData: String(lockData), resolve: { () -> () -> Void in
        let __wrappedFunction = bridge.wrap_Func_void(resolve)
        return { () -> Void in
          __wrappedFunction.call()
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func scanWifi(lockData: std.string, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.scanWifi(lockData: String(lockData), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func configWifi(wifiName: std.string, wifiPassword: std.string, lockData: std.string, resolve: bridge.Func_void, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.configWifi(wifiName: String(wifiName), wifiPassword: String(wifiPassword), lockData: String(lockData), resolve: { () -> () -> Void in
        let __wrappedFunction = bridge.wrap_Func_void(resolve)
        return { () -> Void in
          __wrappedFunction.call()
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func configServer(ip: std.string, port: std.string, lockData: std.string, resolve: bridge.Func_void, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.configServer(ip: String(ip), port: String(port), lockData: String(lockData), resolve: { () -> () -> Void in
        let __wrappedFunction = bridge.wrap_Func_void(resolve)
        return { () -> Void in
          __wrappedFunction.call()
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func getWifiInfo(lockData: std.string, resolve: bridge.Func_void_StringNumberPair, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.getWifiInfo(lockData: String(lockData), resolve: { () -> (StringNumberPair) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_StringNumberPair(resolve)
        return { (__data: StringNumberPair) -> Void in
          __wrappedFunction.call(__data)
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func configIp(info: WifiLockServerInfo, lockData: std.string, resolve: bridge.Func_void, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.configIp(info: info, lockData: String(lockData), resolve: { () -> () -> Void in
        let __wrappedFunction = bridge.wrap_Func_void(resolve)
        return { () -> Void in
          __wrappedFunction.call()
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func getWifiPowerSavingTime(lockData: std.string, resolve: bridge.Func_void_std__string, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.getWifiPowerSavingTime(lockData: String(lockData), resolve: { () -> (String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_std__string(resolve)
        return { (__powerSavingData: String) -> Void in
          __wrappedFunction.call(std.string(__powerSavingData))
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func configWifiPowerSavingTime(days: bridge.std__optional_std__vector_double__, startDate: Double, endDate: Double, lockData: std.string, resolve: bridge.Func_void, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.configWifiPowerSavingTime(days: { () -> [Double]? in
        if bridge.has_value_std__optional_std__vector_double__(days) {
          let __unwrapped = bridge.get_std__optional_std__vector_double__(days)
          return { () -> [Double] in
            let __data = bridge.get_data_std__vector_double_(__unwrapped)
            let __size = __unwrapped.size()
            return Array(UnsafeBufferPointer(start: __data, count: __size))
          }()
        } else {
          return nil
        }
      }(), startDate: startDate, endDate: endDate, lockData: String(lockData), resolve: { () -> () -> Void in
        let __wrappedFunction = bridge.wrap_Func_void(resolve)
        return { () -> Void in
          __wrappedFunction.call()
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func clearWifiPowerSavingTime(lockData: std.string, resolve: bridge.Func_void, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.clearWifiPowerSavingTime(lockData: String(lockData), resolve: { () -> () -> Void in
        let __wrappedFunction = bridge.wrap_Func_void(resolve)
        return { () -> Void in
          __wrappedFunction.call()
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func addFace(cycleList: bridge.std__optional_std__vector_CycleDateParam__, startDate: Double, endDate: Double, lockData: std.string, resolve: bridge.Func_void_std__string, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.addFace(cycleList: { () -> [CycleDateParam]? in
        if bridge.has_value_std__optional_std__vector_CycleDateParam__(cycleList) {
          let __unwrapped = bridge.get_std__optional_std__vector_CycleDateParam__(cycleList)
          return { () -> [CycleDateParam] in
            let __data = bridge.get_data_std__vector_CycleDateParam_(__unwrapped)
            let __size = __unwrapped.size()
            return Array(UnsafeBufferPointer(start: __data, count: __size))
          }()
        } else {
          return nil
        }
      }(), startDate: startDate, endDate: endDate, lockData: String(lockData), resolve: { () -> (String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_std__string(resolve)
        return { (__faceNumber: String) -> Void in
          __wrappedFunction.call(std.string(__faceNumber))
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func addFaceFeatureData(faceFeatureData: std.string, cycleList: bridge.std__optional_std__vector_CycleDateParam__, startDate: Double, endDate: Double, lockData: std.string, resolve: bridge.Func_void_std__string, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.addFaceFeatureData(faceFeatureData: String(faceFeatureData), cycleList: { () -> [CycleDateParam]? in
        if bridge.has_value_std__optional_std__vector_CycleDateParam__(cycleList) {
          let __unwrapped = bridge.get_std__optional_std__vector_CycleDateParam__(cycleList)
          return { () -> [CycleDateParam] in
            let __data = bridge.get_data_std__vector_CycleDateParam_(__unwrapped)
            let __size = __unwrapped.size()
            return Array(UnsafeBufferPointer(start: __data, count: __size))
          }()
        } else {
          return nil
        }
      }(), startDate: startDate, endDate: endDate, lockData: String(lockData), resolve: { () -> (String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_std__string(resolve)
        return { (__faceNumber: String) -> Void in
          __wrappedFunction.call(std.string(__faceNumber))
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func modifyFaceValidityPeriod(cycleList: bridge.std__optional_std__vector_CycleDateParam__, startDate: Double, endDate: Double, faceNumber: std.string, lockData: std.string, resolve: bridge.Func_void, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.modifyFaceValidityPeriod(cycleList: { () -> [CycleDateParam]? in
        if bridge.has_value_std__optional_std__vector_CycleDateParam__(cycleList) {
          let __unwrapped = bridge.get_std__optional_std__vector_CycleDateParam__(cycleList)
          return { () -> [CycleDateParam] in
            let __data = bridge.get_data_std__vector_CycleDateParam_(__unwrapped)
            let __size = __unwrapped.size()
            return Array(UnsafeBufferPointer(start: __data, count: __size))
          }()
        } else {
          return nil
        }
      }(), startDate: startDate, endDate: endDate, faceNumber: String(faceNumber), lockData: String(lockData), resolve: { () -> () -> Void in
        let __wrappedFunction = bridge.wrap_Func_void(resolve)
        return { () -> Void in
          __wrappedFunction.call()
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func deleteFace(faceNumber: std.string, lockData: std.string, resolve: bridge.Func_void, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.deleteFace(faceNumber: String(faceNumber), lockData: String(lockData), resolve: { () -> () -> Void in
        let __wrappedFunction = bridge.wrap_Func_void(resolve)
        return { () -> Void in
          __wrappedFunction.call()
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func clearFace(lockData: std.string, resolve: bridge.Func_void, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.clearFace(lockData: String(lockData), resolve: { () -> () -> Void in
        let __wrappedFunction = bridge.wrap_Func_void(resolve)
        return { () -> Void in
          __wrappedFunction.call()
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func activateLiftFloors(floors: std.string, lockData: std.string, resolve: bridge.Func_void_NumberNumberNumberTriple, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.activateLiftFloors(floors: String(floors), lockData: String(lockData), resolve: { () -> (NumberNumberNumberTriple) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_NumberNumberNumberTriple(resolve)
        return { (__data: NumberNumberNumberTriple) -> Void in
          __wrappedFunction.call(__data)
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func setLiftControlEnableFloors(floors: std.string, lockData: std.string, resolve: bridge.Func_void, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.setLiftControlEnableFloors(floors: String(floors), lockData: String(lockData), resolve: { () -> () -> Void in
        let __wrappedFunction = bridge.wrap_Func_void(resolve)
        return { () -> Void in
          __wrappedFunction.call()
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func setLiftWorkMode(workMode: Double, lockData: std.string, resolve: bridge.Func_void, reject: bridge.Func_void_double_std__string) -> bridge.Result_void_ {
    do {
      try self.__implementation.setLiftWorkMode(workMode: workMode, lockData: String(lockData), resolve: { () -> () -> Void in
        let __wrappedFunction = bridge.wrap_Func_void(resolve)
        return { () -> Void in
          __wrappedFunction.call()
        }
      }(), reject: { () -> (Double, String) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double_std__string(reject)
        return { (__errorCode: Double, __description: String) -> Void in
          __wrappedFunction.call(__errorCode, std.string(__description))
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func getBluetoothState(resolve: bridge.Func_void_double) -> bridge.Result_void_ {
    do {
      try self.__implementation.getBluetoothState(resolve: { () -> (Double) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_double(resolve)
        return { (__state: Double) -> Void in
          __wrappedFunction.call(__state)
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func supportFunction(lockFunction: Double, lockData: std.string, resolve: bridge.Func_void_bool) -> bridge.Result_void_ {
    do {
      try self.__implementation.supportFunction(lockFunction: lockFunction, lockData: String(lockData), resolve: { () -> (Bool) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_bool(resolve)
        return { (__isSupport: Bool) -> Void in
          __wrappedFunction.call(__isSupport)
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func addListener(eventName: std.string, listener: bridge.Func_void_std__string_std__optional_std__shared_ptr_AnyMap__) -> bridge.Result_void_ {
    do {
      try self.__implementation.addListener(eventName: String(eventName), listener: { () -> (String, AnyMap?) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_std__string_std__optional_std__shared_ptr_AnyMap__(listener)
        return { (__eventName: String, __data: AnyMap?) -> Void in
          __wrappedFunction.call(std.string(__eventName), { () -> bridge.std__optional_std__shared_ptr_AnyMap__ in
            if let __unwrappedValue = __data {
              return bridge.create_std__optional_std__shared_ptr_AnyMap__(__unwrappedValue.cppPart)
            } else {
              return .init()
            }
          }())
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
  
  @inline(__always)
  public final func removeListener(eventName: std.string, listener: bridge.Func_void_std__string_std__optional_std__shared_ptr_AnyMap__) -> bridge.Result_void_ {
    do {
      try self.__implementation.removeListener(eventName: String(eventName), listener: { () -> (String, AnyMap?) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_std__string_std__optional_std__shared_ptr_AnyMap__(listener)
        return { (__eventName: String, __data: AnyMap?) -> Void in
          __wrappedFunction.call(std.string(__eventName), { () -> bridge.std__optional_std__shared_ptr_AnyMap__ in
            if let __unwrappedValue = __data {
              return bridge.create_std__optional_std__shared_ptr_AnyMap__(__unwrappedValue.cppPart)
            } else {
              return .init()
            }
          }())
        }
      }())
      return bridge.create_Result_void_()
    } catch (let __error) {
      let __exceptionPtr = __error.toCpp()
      return bridge.create_Result_void_(__exceptionPtr)
    }
  }
}
